<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ConnectSphere Solo</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.css" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f4f4f9;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .container {
      max-width: 600px;
      width: 100%;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .scan-section, .results-section, .map-section {
      margin-bottom: 20px;
    }
    button {
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover {
      background-color: #0056b3;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    ul {
      list-style: none;
      padding: 0;
    }
    li {
      padding: 10px;
      border-bottom: 1px solid #eee;
    }
    #map {
      height: 300px;
      width: 100%;
      border-radius: 4px;
    }
    .error {
      color: red;
      text-align: center;
    }
    .note {
      color: #555;
      font-size: 14px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ConnectSphere Solo</h1>

    <!-- Scan Section -->
    <div class="scan-section" id="scanSection">
      <button id="scanBluetoothButton" disabled>Scanning Bluetooth Devices...</button>
      <button id="scanNFCButton" style="display: none;">Scan NFC Devices</button>
      <button id="retryGeolocationButton" style="display: none;">Retry Geolocation</button>
      <p class="note">Note: Bluetooth scanning requires Chrome or Edge with Bluetooth enabled. NFC scanning requires Chrome on Android with NFC enabled. Wi-Fi scanning is not supported in browsers.</p>
    </div>

    <!-- Results Section -->
    <div class="results-section">
      <h2>Nearby Devices</h2>
      <ul id="deviceList"></ul>
      <p id="errorMessage" class="error"></p>
    </div>

    <!-- Map Section -->
    <div class="map-section">
      <h2>Device Map</h2>
      <div id="map"></div>
    </div>
  </div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.js"></script>
  <script>
    // Mapbox access token (replace with your own token from https://mapbox.com)
    mapboxgl.accessToken = 'YOUR_MAPBOX_ACCESS_TOKEN';

    // Device list storage (in-memory, cleared on refresh)
    let devices = [];

    // Parse manufacturer-specific data
    function parseManufacturerData(manufacturerData) {
      if (!manufacturerData) return 'N/A';
      
      const data = new DataView(manufacturerData);
      const manufacturerId = data.getUint16(0, true);
      
      // Known manufacturer IDs
      const manufacturers = {
        0x004C: 'Apple',
        0x0006: 'Microsoft',
        0x0075: 'Samsung',
        0x0059: 'Nordic Semiconductor'
      };
      
      return {
        manufacturer: manufacturers[manufacturerId] || `Unknown (0x${manufacturerId.toString(16)})`,
        rawData: Array.from(new Uint8Array(manufacturerData)).map(b => b.toString(16).padStart(2, '0')).join('')
      };
    }

    // Check for common BLE vulnerabilities
    function checkVulnerabilities(device, services) {
      const vulnerabilities = [];
      
      // Check for weak security
      if (device.gatt && (!device.gatt.security || device.gatt.security === 'low')) {
        vulnerabilities.push('Weak or no security level');
      }

      // Check for sensitive services with no encryption
      services.forEach(service => {
        if (service.isPrimary && !service.secure) {
          vulnerabilities.push(`Unencrypted sensitive service: ${service.uuid}`);
        }
      });

      // Check for common misconfigurations
      if (!device.name) {
        vulnerabilities.push('Device name broadcasting disabled - potential hidden device');
      }

      return vulnerabilities;
    }

    // Initialize Mapbox map
    let map;
    function initMap(latitude = 0, longitude = 0, zoom = 2, showMarker = false) {
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v11',
        center: [longitude, latitude],
        zoom: zoom,
      });
      if (showMarker) {
        new mapboxgl.Marker().setLngLat([longitude, latitude]).addTo(map);
      }
    }

    function tryGeolocation() {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const { latitude, longitude } = position.coords;
          initMap(latitude, longitude, 15, true);
          document.getElementById('retryGeolocationButton').style.display = 'none';
          document.getElementById('errorMessage').textContent = '';
        },
        (error) => {
          console.error('Geolocation error:', error);
          initMap(); // Fallback to default coordinates
          document.getElementById('errorMessage').textContent = 'Geolocation access denied. Map centered at default location. Click "Retry Geolocation" to try again.';
          document.getElementById('retryGeolocationButton').style.display = 'block';
        },
        { timeout: 10000 } // 10-second timeout
      );
    }

    // Initial geolocation attempt
    tryGeolocation();

    // Retry geolocation on button click
    document.getElementById('retryGeolocationButton').addEventListener('click', tryGeolocation);

    // Bluetooth scanning function
    async function scanBluetooth() {
      document.getElementById('scanBluetoothButton').disabled = true;
      document.getElementById('errorMessage').textContent = '';

      try {
        const device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: [
            'device_information',
            'battery_service',
            'generic_access',
            'heart_rate',
            'health_thermometer',
            'human_interface_device',
            'immediate_alert',
            'link_loss',
            'location_and_navigation',
            'phone_alert_status',
            'reference_time_update',
            'running_speed_and_cadence',
            'scan_parameters',
            'tx_power',
            'user_data',
            'weight_scale'
          ],
        });

        // Store RSSI and device class if available
        const deviceClass = device.deviceClass || 'Unknown';
        const rssi = device.adData ? device.adData.rssi : 'N/A';
        
        // Connect to the device to retrieve more information
        const server = await device.gatt.connect();
        const services = await server.getPrimaryServices();

        const deviceInfo = {
          name: device.name || 'Unknown Device',
          id: device.id,
          type: 'Bluetooth',
          timestamp: new Date().toLocaleTimeString(),
          deviceClass: deviceClass,
          rssi: rssi,
          services: [],
          securityLevel: server.security || 'Unknown',
          connectionState: device.gatt.connected ? 'Connected' : 'Disconnected',
          manufacturerData: device.adData ? parseManufacturerData(device.adData.manufacturerData) : 'N/A',
          vulnerabilities: [],
        };

        // Retrieve details from each service
        for (const service of services) {
          const characteristics = await service.getCharacteristics();
          const serviceData = {
            uuid: service.uuid,
            characteristics: [],
          };

          for (const characteristic of characteristics) {
            try {
              const value = await characteristic.readValue();
              const decoder = new TextDecoder('utf-8');
              serviceData.characteristics.push({
                uuid: characteristic.uuid,
                value: decoder.decode(value) || 'N/A',
              });
            } catch (err) {
              serviceData.characteristics.push({
                uuid: characteristic.uuid,
                value: 'Error reading value',
              });
            }
          }
          deviceInfo.services.push(serviceData);
        }

        // Disconnect after retrieving data
        server.disconnect();

        if (!devices.some(d => d.id === deviceInfo.id)) {
          devices.push(deviceInfo);
          updateDeviceList();
          addDeviceToMap(deviceInfo);
        }
      } catch (error) {
        document.getElementById('errorMessage').textContent = 'Bluetooth scan failed: ' + error.message;
      } finally {
        document.getElementById('scanBluetoothButton').disabled = false;
        document.getElementById('scanBluetoothButton').textContent = 'Scan Bluetooth Devices Again';
      }
    }

    // NFC scanning function (if supported)
    async function scanNFC() {
      document.getElementById('scanNFCButton').disabled = true;
      document.getElementById('errorMessage').textContent = '';

      try {
        const ndef = new NDEFReader();
        await ndef.scan();
        ndef.onreading = ({ message, serialNumber }) => {
          const deviceInfo = {
            name: 'NFC Device',
            id: serialNumber || `nfc-${Date.now()}`,
            type: 'NFC',
            timestamp: new Date().toLocaleTimeString(),
            records: message.records.map(record => ({
              recordType: record.recordType,
              data: record.data ? new TextDecoder().decode(record.data) : 'N/A',
            })),
          };

          if (!devices.some(d => d.id === deviceInfo.id)) {
            devices.push(deviceInfo);
            updateDeviceList();
            addDeviceToMap(deviceInfo);
          }
        };
      } catch (error) {
        document.getElementById('errorMessage').textContent = 'NFC scan failed: ' + error.message;
      } finally {
        document.getElementById('scanNFCButton').disabled = false;
        document.getElementById('scanNFCButton').textContent = 'Scan NFC Devices Again';
      }
    }

    // Initialize scanning based on browser support
    window.addEventListener('load', () => {
      // Bluetooth scanning
      if ('bluetooth' in navigator) {
        scanBluetooth();
      } else {
        document.getElementById('errorMessage').textContent = 'Web Bluetooth API not supported. Use Chrome or Edge on a desktop or mobile device with Bluetooth enabled.';
        document.getElementById('scanBluetoothButton').disabled = true;
        document.getElementById('scanBluetoothButton').textContent = 'Bluetooth Not Supported';
      }

      // NFC scanning
      if ('NDEFReader' in window) {
        document.getElementById('scanNFCButton').style.display = 'block';
        document.getElementById('scanNFCButton').addEventListener('click', scanNFC);
      }
    });

    // Allow manual Bluetooth re-scanning
    document.getElementById('scanBluetoothButton').addEventListener('click', scanBluetooth);

    // Update device list in UI
    function updateDeviceList() {
      const deviceList = document.getElementById('deviceList');
      deviceList.innerHTML = '';
      devices.forEach(device => {
        const li = document.createElement('li');
        li.style.backgroundColor = device.vulnerabilities.length > 0 ? '#fff3f3' : 'transparent';
        
        let details = `
          <strong>${device.name}</strong><br>
          Type: ${device.type}<br>
          Detected: ${device.timestamp}<br>
          Device Class: ${device.deviceClass}<br>
          RSSI: ${device.rssi} dBm<br>
          Security Level: ${device.securityLevel}<br>
          Connection State: ${device.connectionState}<br>
          Manufacturer: ${typeof device.manufacturerData === 'object' ? device.manufacturerData.manufacturer : device.manufacturerData}
        `;
        
        if (device.vulnerabilities && device.vulnerabilities.length > 0) {
          details += '<div style="color: red"><strong>Vulnerabilities Found:</strong><ul>';
          device.vulnerabilities.forEach(vuln => {
            details += `<li>${vuln}</li>`;
          });
          details += '</ul></div>';
        }
        
        if (device.services && device.services.length > 0) {
          details += '<strong>Services:</strong><ul>';
          device.services.forEach(service => {
            details += `<li>Service: ${service.uuid}`;
            if (service.characteristics.length > 0) {
              details += '<ul>';
              service.characteristics.forEach(char => {
                details += `<li>Characteristic: ${char.uuid}, Value: ${char.value}</li>`;
              });
              details += '</ul>';
            }
            details += '</li>';
          });
          details += '</ul>';
        } else if (device.records && device.records.length > 0) {
          details += '<ul>';
          device.records.forEach(record => {
            details += `<li>Record Type: ${record.recordType}, Data: ${record.data}</li>`;
          });
          details += '</ul>';
        }
        li.innerHTML = details;
        deviceList.appendChild(li);
      });
    }

    // Add device to map (approximate position)
    function addDeviceToMap(device) {
      if (!map) return;

      navigator.geolocation.getCurrentPosition(
        (position) => {
          const { longitude, latitude } = position.coords;
          const offset = (Math.random() - 0.5) * 0.001;
          new mapboxgl.Marker({ color: device.type === 'Bluetooth' ? '#007bff' : '#ff4444' })
            .setLngLat([longitude + offset, latitude + offset])
            .setPopup(new mapboxgl.Popup().setText(device.name))
            .addTo(map);
        },
        () => {
          const offset = (Math.random() - 0.5) * 0.001;
          new mapboxgl.Marker({ color: device.type === 'Bluetooth' ? '#007bff' : '#ff4444' })
            .setLngLat([offset, offset])
            .setPopup(new mapboxgl.Popup().setText(device.name))
            .addTo(map);
        }
      );
    }
  </script>
</body>
</html>
